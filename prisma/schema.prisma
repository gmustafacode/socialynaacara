generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id             String          @id @default(uuid())
  name           String?
  email          String          @unique
  password       String?
  emailVerified  DateTime?
  image          String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  accounts       Account[]
  aiLogs         AiLog[]
  contentQueue   ContentQueue[]
  linkedinPosts  LinkedInPost[]
  postHistory    PostHistory[]
  preferences    Preference?
  scheduledPosts ScheduledPost[]
  sessions       Session[]
  socialAccounts SocialAccount[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model SocialAccount {
  id                    String          @id @default(uuid())
  userId                String
  platform              String
  platformAccountId     String?
  encryptedAccessToken  String?
  encryptedRefreshToken String?
  encryptedClientId     String?
  encryptedClientSecret String?
  customRedirectUri     String?
  scopes                String?
  metadata              String?
  status                String          @default("active")
  connectedAt           DateTime        @default(now())
  lastVerifiedAt        DateTime?
  capabilities          Json?
  updatedAt             DateTime        @updatedAt
  accessTokenExpiresAt  DateTime?       @map("access_token_expires_at")
  linkedinPosts         LinkedInPost[]
  scheduledPosts        ScheduledPost[]
  user                  User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform], name: "user_platform_unique")
  @@unique([platform, platformAccountId], name: "platform_platformAccountId")
  @@index([userId])
  @@index([platform])
  @@index([status])
  @@map("social_accounts")
}

model Preference {
  id                    String   @id @default(uuid())
  userId                String   @unique
  brandName             String?
  profileType           String?  // Personal, Business, Creator
  audienceType          String?
  industryNiche         String?
  contentGoals          String?
  preferredPlatforms    String[] @default([])
  preferredContentTypes String[] @default([])
  postingSchedule       Json?    // Using Json for more flexible schedule storage
  postingFrequency      String?
  automationLevel       String?  // Manual, Semi-Auto, Full Auto
  onboardingCompleted   Boolean  @default(false)
  notificationsEnabled  Boolean  @default(true)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("preferences")
}


model ContentQueue {
  id             String             @id @default(uuid())
  userId         String?            @map("user_id")
  source         String
  contentType    String             @map("content_type")
  title          String?
  summary        String?
  rawContent     String?            @map("raw_content")
  mediaUrl       String?            @map("media_url")
  sourceUrl      String?            @unique @map("source_url")
  language       String             @default("en")
  status         String             @default("pending")
  viralScore     Int                @default(0) @map("viral_score")
  fetchedAt      DateTime           @default(now()) @map("fetched_at")
  scheduledAt    DateTime?          @map("scheduled_at")
  createdAt      DateTime           @default(now()) @map("created_at")
  updatedAt      DateTime           @updatedAt @map("updated_at")
  author         String?
  metadata       Json?
  publishedAt    DateTime?          @map("published_at")
  finalScore     Float?             @map("final_score")
  decisionReason String?            @map("decision_reason")
  analyzedAt     DateTime?          @map("analyzed_at")
  aiStatus       String?            @map("ai_status")
  aiAnalysis     ContentAiAnalysis?
  user           User?              @relation(fields: [userId], references: [id], onDelete: Cascade)
  postHistory    PostHistory[]

  @@index([status])
  @@index([scheduledAt])
  @@index([userId])
  @@index([viralScore(sort: Desc), createdAt(sort: Desc)])
  @@map("content_queue")
}

model PostHistory {
  id                String        @id @default(uuid())
  userId            String
  platform          String
  contentId         String?
  postId            String?
  engagementMetrics String?
  status            String
  postedAt          DateTime      @default(now())
  content           ContentQueue? @relation(fields: [contentId], references: [id], onDelete: Cascade)
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([contentId])
  @@map("post_history")
}

model AiLog {
  id            String   @id @default(uuid())
  userId        String
  agentName     String
  action        String
  outputSummary String?
  createdAt     DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("ai_logs")
}

model ScheduledPost {
  id              String        @id @default(uuid())
  userId          String
  socialAccountId String
  platform        String
  postType        String
  contentText     String
  mediaUrl        String?
  targetType      String
  targetId        String?
  scheduledAt     DateTime?
  status          String        @default("pending")
  externalPostId  String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  timezone        String?
  retryCount      Int           @default(0) @map("retry_count")
  lastError       String?       @map("last_error")
  publishedAt     DateTime?     @map("published_at")
  contentId       String?       @map("content_id")
  socialAccount   SocialAccount @relation(fields: [socialAccountId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([scheduledAt])
  @@index([status, scheduledAt])
  @@map("scheduled_posts")
}

model CronExecutionLog {
  id              String    @id @default(uuid())
  startedAt       DateTime  @map("started_at")
  finishedAt      DateTime? @map("finished_at")
  processed       Int       @default(0)
  published       Int       @default(0)
  failed          Int       @default(0)
  executionTimeMs Int?      @map("execution_time_ms")
  errorsCount     Int       @default(0) @map("errors_count")
  createdAt       DateTime  @default(now()) @map("created_at")

  @@map("cron_execution_logs")
}

model LinkedInPost {
  id                    String        @id @default(uuid())
  userId                String
  socialAccountId       String
  postType              String        @default("TEXT")
  youtubeUrl            String?
  title                 String?
  description           String        @default("")
  thumbnailUrl          String?
  mediaUrls             String[]      @default([])
  targetType            String
  groupIds              String[]
  visibility            String        @default("PUBLIC")
  status                String        @default("DRAFT")
  encryptedAccessToken  String?       @map("encrypted_access_token")
  encryptedRefreshToken String?       @map("encrypted_refresh_token")
  encryptedClientId     String?       @map("encrypted_client_id")
  encryptedClientSecret String?       @map("encrypted_client_secret")
  accessTokenExpiresAt  DateTime?     @map("access_token_expires_at")
  linkedinPostUrn       String?
  errorMessage          String?
  scheduledAt           DateTime?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  socialAccount         SocialAccount @relation(fields: [socialAccountId], references: [id], onDelete: Cascade)
  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([scheduledAt])
  @@map("linkedin_posts")
}

model IngestionLog {
  id             String   @id @default(uuid())
  source         String
  fetchedCount   Int      @default(0) @map("fetched_count")
  savedCount     Int      @default(0) @map("saved_count")
  duplicateCount Int      @default(0) @map("duplicate_count")
  errorCount     Int      @default(0) @map("error_count")
  executionTime  Int      @default(0) @map("execution_time")
  errorMessage   String?  @map("error_message")
  createdAt      DateTime @default(now()) @map("created_at")

  @@map("ingestion_logs")
}

model ContentAiAnalysis {
  id                        String       @id @default(uuid())
  contentId                 String       @unique @map("content_id")
  category                  String
  contentQualityScore       Int          @map("content_quality_score")
  engagementScore           Int          @map("engagement_score")
  viralityProbability       Int          @map("virality_probability")
  finalScore                Float        @map("final_score")
  recommendedPlatforms      Json         @map("recommended_platforms")
  contentTypeRecommendation String       @map("content_type_recommendation")
  rewriteNeeded             Boolean      @map("rewrite_needed")
  reasoning                 String
  rawLlmResponse            Json         @map("raw_llm_response")
  createdAt                 DateTime     @default(now()) @map("created_at")
  content                   ContentQueue @relation(fields: [contentId], references: [id], onDelete: Cascade)

  @@index([contentId])
  @@map("content_ai_analysis")
}

model AiProcessingLog {
  id            String   @id @default(uuid())
  batchId       String   @map("batch_id")
  batchSize     Int      @map("batch_size")
  processed     Int
  approved      Int
  review        Int
  rejected      Int
  aiErrors      Int      @map("ai_errors")
  executionTime Int      @map("execution_time")
  startedAt     DateTime @map("started_at")
  finishedAt    DateTime @map("finished_at")
  createdAt     DateTime @default(now()) @map("created_at")

  @@map("ai_processing_logs")
}

model AiLearningExample {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  postId         String   @map("post_id")
  contentText    String   @map("content_text")
  sentimentScore Int      @map("sentiment_score")
  category       String
  keyLearnings   String   @map("key_learnings")
  createdAt      DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([category])
  @@index([sentimentScore])
  @@map("ai_learning_examples")
}
